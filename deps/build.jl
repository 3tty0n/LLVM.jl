# entry point for Pkg: performs all necessary build-time tasks, and writes ext.jl

include("compile.jl")

const ext = joinpath(@__DIR__, "ext.jl")
const ext_bak = joinpath(ext, ".bak")

function main()
    debug("Performing package build for LLVM.jl from $(pwd())")
    ispath(ext) && mv(ext, ext_bak)

    llvms = discover_llvm()
    wrappers = discover_wrappers()
    julia = discover_julia()

    llvm = select_llvm(llvms, wrappers)
    wrapper = select_wrapper(llvm, wrappers)


    #
    # Detect changes
    #

    # gather LLVM information
    llvm_targets = Symbol.(split(readstring(`$(get(llvm.config)) --targets-built`)))

    # gather LLVM.jl information
    llvmjl_hash =
        try
            cd(joinpath(@__DIR__, "..")) do
                chomp(readstring(`git rev-parse HEAD`))
            end
        catch e
            warning("could not find package git hash")
            # NOTE: we don't explicitly check for llvmjl_hash==nothing, because
            #       it will imply that llvmjl_dirty=true, making us rebuild anyway
            nothing
        end
    llvmjl_dirty =
        try
            cd(joinpath(@__DIR__, "..")) do
                length(chomp(readstring(`git diff --shortstat`))) > 0
            end
        catch e
            warning("could not find package git status")
            true
        end

    # check if anything has changed (to prevent unnecessary recompilation)
    if llvmjl_dirty
        debug("Package is dirty, rebuilding")
    elseif isfile(ext_bak)
        debug("Checking validity of existing ext.jl...")
        @eval module Previous; include($ext_bak); end
        if  isdefined(Previous, :libllvm_version) && Previous.libllvm_version == llvm.version &&
            isdefined(Previous, :libllvm_path)    && Previous.libllvm_path == llvm.path &&
            isdefined(Previous, :libllvm_mtime)   && Previous.libllvm_mtime == llvm.mtime &&
            isdefined(Previous, :llvm_targets)    && Previous.llvm_targets == llvm_targets &&
            isdefined(Previous, :wrapper)         && Previous.wrapper == wrapper &&
            isdefined(Previous, :llvmjl_hash)     && Previous.llvmjl_hash == llvmjl_hash
            info("LLVM.jl has already been built for this toolchain, no need to rebuild")
            mv(ext_bak, ext)
            return
        end
    end


    #
    # Acquire extras library
    #

    # TODO: download from buildbot if !llvmjl_dirty

    extras_path = compile_extras(llvm, julia)


    #
    # Finishing up
    #

    # write ext.jl
    open(ext, "w") do fh
        write(fh, """
            # autogenerated file with properties of the toolchain

            # LLVM library properties
            const libllvm_version = v"$(llvm.version)"
            const libllvm_path    = "$(llvm.path)"
            const libllvm_mtime   = $(llvm.mtime)
            const libllvm_system  = $use_system_llvm
            const libllvm_targets = $llvm_targets

            # LLVM extras library properties
            const libllvm_extra_path = "$extras_path"

            # package properties
            const llvmjl_wrapper = "$wrapper"
            const llvmjl_hash    = "$llvmjl_hash"
            """)
    end

    # refresh the compile cache
    # NOTE: we need to do this manually, as the package will load & precompile after
    #       not having loaded a nonexistent ext.jl in the case of a failed build,
    #       causing it not to precompile after a subsequent successful build.
    Base.compilecache("LLVM")

    return
end

main()
